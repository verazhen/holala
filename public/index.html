<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="shortcut icon" href="%PUBLIC_URL%/favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#1A73E8" />
    <link
      rel="apple-touch-icon"
      sizes="76x76"
      href="%PUBLIC_URL%/apple-icon.png"
    />
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <title>HOLALA</title>
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap"
    />
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"
      integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A=="
      crossorigin=""
    />
    <link
      href="https://fonts.googleapis.com/css?family=Material+Icons|Material+Icons+Outlined|Material+Icons+Two+Tone|Material+Icons+Round|Material+Icons+Sharp"
      rel="stylesheet"
    />
    <script
      src="https://cdn.socket.io/4.5.0/socket.io.min.js"
      integrity="sha384-7EyYLQZgWBi67fBtVxw60/OWl1kjsfrPFcaU0pp0nAh+i8FD068QogUvg85Ewy1k"
      crossorigin="anonymous"
    ></script>
  </head>

  <body>
    <script src="%PUBLIC_URL%/constants.js"></script>
    <div
      id="video-container"
      style="
        height: 250px;
        width: 60vw;
        over-flow: auto;
        position: absolute;
        z-index: 9999;
        bottom: 20px;
        left: 270px;
        padding: 20px;
      "
    >
      <video
        autoplay
        playsinline
        muted
        style="height: 210px; width: 290px; border-radius: 15px"
        id="rtc"
      ></video>
    </div>
    <script src="%PUBLIC_URL%/peer.js"></script>
    <script>
      let mediaRecorder;
      let uploadUrl;
      let rtc;
      let localStream;
      async function recordScreen() {
        return await navigator.mediaDevices.getDisplayMedia({
          audio: true,
          video: { mediaSource: "screen" },
        });
      }

      function createRecorder(stream, mimeType) {
        // the stream data is stored in this array
        let recordedChunks = [];

        const mediaRecorder = new MediaRecorder(stream);

        mediaRecorder.ondataavailable = function (e) {
          if (e.data.size > 0) {
            recordedChunks.push(e.data);
          }
        };
        mediaRecorder.onstop = function () {
          saveFile(recordedChunks);
          recordedChunks = [];
        };
        mediaRecorder.start(200); // For every 200ms the stream data will be stored in a separate chunk.
        return mediaRecorder;
      }

      function saveFile(recordedChunks) {
        const blob = new Blob(recordedChunks, {
          type: "video/webm",
        });
        console.log(blob);
        fetch(uploadUrl, {
          method: "PUT",
          headers: {
            "Content-Type": "video/mp4",
          },
          body: blob,
        });
      }

      function createVideoTag(id) {
        // the stream data is stored in this array
        const container = document.getElementById("video-container");
        const myVideo = document.getElementById("rtc");
        const video = myVideo.cloneNode(false);
        video.removeAttribute("id");
        video.id = id;
        container.append(video);
        return video;
      }

      function createPeer(userToSignal, callerID, stream) {
        //set local stream and create signal
        const peer = new SimplePeer({
          initiator: true,
          trickle: false,
          stream,
        });
        console.log("new peer", peer);

        peer.on("signal", (signal) => {
          console.log("signal", signal);
          rtc.emit("sending signal", {
            userToSignal,
            callerID,
            signal,
          });
        });
        console.log("createPeer");

        const video = createVideoTag(userToSignal);

        peer.on("stream", (stream) => {
          console.log("接收流並顯示於遠端視訊！", stream);
          video.srcObject = stream;
        });

        return peer;
      }

      function addPeer(incomingSignal, callerID, stream) {
        const peer = new SimplePeer({
          initiator: false,
          trickle: false,
          stream,
        });

        peer.on("signal", (signal) => {
          console.log("returning signal", signal);
          rtc.emit("returning signal", { signal, callerID });
        });
        console.log("addPeer");

        createVideoTag(callerID);

        peer.on("stream", (stream) => {
          console.log("接收流並顯示於遠端視訊！", stream);
          document.getElementById(callerID).srcObject = stream;
        });

        peer.signal(incomingSignal);

        return peer;
      }

      document.getElementById("video-container").style.display = "none";

      window.initRtc = () => {
        console.log("----------init rtc---------");
        let peers = [];
        document.getElementById("video-container").style.display = "block";
        rtc = window.io.connect(SOCKET_HOST);
        const uid = localStorage.getItem("uid");
        const kanbanId = localStorage.getItem("kanbanId");
        rtc.emit("get room", { uid, kanbanId });
        navigator.mediaDevices
          .getUserMedia({ video: true, audio: true })
          .then((stream) => {
            localStream = stream;
            document.getElementById("rtc").srcObject = localStream;
          });

        //listen while meeting is started
        rtc.on("get room", (data) => {
          if (data.isNewRoom) {
            recordScreen().then((record) => {
              mediaRecorder = createRecorder(record, "video/mp4");
            });
          }
        });

        rtc.on("leave room", ({ message, result }) => {
          if (result === 3) {
            uploadUrl = result;
            mediaRecorder.stop();
          }
        });

        rtc.emit("join room", kanbanId);
        console.log(`you've joined a meeting room`);
        rtc.on("all users", (users) => {
          //initialized online users
          users.forEach((userID) => {
            const peer = createPeer(userID, rtc.id, localStream);
            peers.push({
              peerID: userID,
              peer,
            });
          });
        });

        rtc.on("user joined", (payload) => {
          const peer = addPeer(payload.signal, payload.callerID, localStream);
          peers.push({
            peerID: payload.callerID,
            peer,
          });
        });

        rtc.on("receiving returned signal", (payload) => {
          const item = peers.find((p) => p.peerID === payload.id);
          item.peer.signal(payload.signal);
        });

        rtc.on("user left", (id) => {
          peers = peers.filter((p) => p.peerID !== id);
          const video = document.getElementById(id);
          video.remove();
        });
      };

      window.closeRtc = () => {
        console.log("----------close rtc---------");
        document.getElementById("video-container").style.display = "none";
        const uid = localStorage.getItem("uid");
        const kanbanId = localStorage.getItem("kanbanId");
        rtc.emit("leave room", { uid, kanbanId });
        rtc.emit("leave meet", kanbanId);
        rtc.disconnect();
        if (localStream.getTracks()) {
          localStream.getTracks().forEach((track) => {
            track.stop();
          });
        }
        document.querySelectorAll("video").forEach((video) => {
          if (video.id !== "rtc") {
            video.remove();
          }
        });
      };
    </script>
    <div id="root"></div>
  </body>
</html>
